
/* Binary Search
*
* What is binary search?
*   A searching algorithm used only on sorted arrays. It states that:- (1) Find the middle element in the 
* sorted array, (2) if target element is less than the middle element, search in the left side. Else,
* search in the right hand side of the array.(3) If middle element is the target element, then that 
* concludes the search.[NOTE:- Step 2 may be repeated, and Step 3 will be checked each time that happens]
* if Start becomes greater than end - Element not found
*
*
* Why do we use Binary Search?
    - The best case for a binary search is, finding the element being searched for in first search, which 
    is the middle element. O(1) - Best case for Binary Search 
    - The worst case for binary search is when comparison is either not found, or is found at the last 
    search. {log[base 2]N} ie., O(logN) - worst case for Binary Search
* Hence, if we have to make 1,000,000 comparisons, with lenear search we will have to search 1 million
* times, but when it comes to Binary Search, It only takes 20 Comparisons.

// Binary search implementation through code

sol] // we assume an ascending order array for this
package javatpoint;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;


public class Student{
	public static void main(String[] args) {
		int[] arr = {-23,-12,-4,0,23,45,67,89,100};
		int target = -23;
		int ans = binarySearch(arr,target);
		System.out.println(ans);
	}
	//this search is for ascending order array
	static int binarySearch(int[] arr,int target) {
		
		int start = 0;
		int end = arr.length-1;
		
		while(start <= end) {
		//	To find middle element
		//	int mid = (start+end)/2 // might be possible that(start+end) exceed the range of integer in java  
		//  So we use,
			int middle = start+(end-start)/2;
			
			if(target < arr[middle]) { // search left side
				end = middle - 1;
			}else if(target > arr[middle]) { //search right side
				start = middle + 1;
			}else {
				//answer found as the middle value
				return middle;
			}
		}
		//if none of the return have worked, then.
		return -1;//if target not found
	}
	
	
}


op:-

0

/* NOTE:-  For the above program we assumed a sorted array, we are going to see how to use binary search on 
*  unsorted array 
*/

//Q1] find the target element in a descending order array, using binary search

sol]
package javatpoint;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;


public class Student{
	public static void main(String[] args) {
		int[] arr = {78,67,54,43,32,22,20,17,8,3,1};
		int target = 54;
		int ans = binarySearch(arr,target);
		System.out.println(ans);
	}
	//this search is for ascending order array
	static int binarySearch(int[] arr,int target) {
		
		int start = 0; //78
		int end = arr.length-1; //1
		
		while(start<=end) {
			int middle = start + (end-start)/2; //22
//MAJOR NOTE:- There is difference between {(start+end)/2} and {start + (end-start)/2}, for the later, only second term in bracket is divided by 2, 
	       then it is added to start. for the former both are divided by 2.			
			if(target>arr[middle]) {
				end = middle-1; 
			}else if(target<arr[middle]) {
				start = middle+1;
			}else {
				return middle;
			}
		}
		
		return -1;
		
	}
}


op:- 
2


// Order Agonistic binary search
/* 
*  Means, you are given a sorted array, but dont know whether it is ascending or descending order array.
*  Say, suppose we are given an array - [23,13,11,10,5,2,1] - we can compare the 0th and 1st element and
*  conclude that, it is in descending order. 
*  But, what if the array is [2(f),2,2,2,4,56(s)] - in such case we can find out by comparing first and last element
*  So, we can say that - 
*	if(start(s) > first(f)) --> it is in descending order(increasing order)
*	else                    --> it is in ascending order(decreasing order)
* So, in conclusion. In order agonistic binary search, we first are given with an sorted array, but we dont
* know if it is in ascending or descending. Using the formula above we figure out and apply the method to
* find the target elements index value. These are the 3 steps.
*/

//example

package javatpoint;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;


public class Student{
	public static void main(String[] args) {
		//asc order array
//		int[] arr = {-18, -12, -4, 0, 2, 3, 4, 15, 16, 18, 22, 45, 89};
		
		//dsc order array
		int[] arr = {99, 54, 44, 33, 22, 11, 5, 2};
		
		int target = 22;
		int ans = orderAgnosticBS(arr,target);
		System.out.println(ans);
	}
	//order agnostic binary search
	static int orderAgnosticBS(int[] arr, int target) {
		
		int start = 0;
		int end = arr.length - 1;
		
		//find whether the array is sorted in ascending or descending order
		
		boolean isAsc = arr[start] < arr[end];
		/* The below block of code can be optimised above
		  boolean isAsc;
		if(arr[start]<arr[end]) {
			isAsc = true;
		}else {
			isAsc = false;
		} 
		*/
		
		while(start <= end) {
			int middle = start + (end-start)/2;
			
			if(arr[middle] == target) {
				return middle;
			}
			
			if(isAsc) {
				if(target<arr[middle]) {
					end = middle - 1;
				}else{   // target>arr[middle]
					start = middle + 1;
				}
			}else {      //isAsc = false
				if(target>arr[middle]) {
					end = middle - 1;
				}else {  // target<arr[middle]
					start = middle + 1;
				}
			}
		}	
		return -1;
	}
}

op:- 

4

********

SO,When do we use/need binary search?

:- If a question is present with sorted array, then we use binary search. BUT IT IS NOT THE SOLUTION FOR 100% OF 
   THE TIME!!!

Floor and Ceiling of a number using BS
--------------------------------------

//Ceiling of a given number, using BS
	
//Ceiling of a given number is nothing but, the Smallest element of the array is greater than or equal to target element.
	
/* lets assume a sorted array,
 * 
 * arr = [2,3,4,5,9,14,16];
 * {Tip: If you see a sorted array, use BS. If the result is not found, try  another method}
 * 
 * //if,
 * target = 14; //case 1
 * //Then, ceiling is going to be 14. Since it is greater or equal to 14.
 * 
 * //if,
 * target = 15, //case 2
 * //As we can notice, the target element 15 does not exist in the array, so we check for the greatest element in the array, 
 *   which is 16. hence, the ceiling is 16.
 * 
 * //So,
 * in order to find the ceiling of a number in a SORTED array we have 3 steps
 * 1] check if target element exists in array[like case 1]
 * 2] if not, then find all the elements that are greater than or equal to the target element [like case 2] 
 * 3] Which is the smallest number from the second step?, hence the result!!
 * 
*/

(EG):- To find Ceiling of a array using BS

sol]
package javatpoint;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;


public class Student{
	public static void main(String[] args) {
	
	//find the ceiling of a number using BS
	// Ceiling of a given number is nothing but, the Smallest element of
	// the array is greater than or equal to target element.
	int[] arr= {2,3,5,9,14,16,18}; //sorted array
	int target = 15;
	int ans = ceiling(arr,target);
	System.out.println("The ceiling of the array is in index: "+ans);
	}
	
	static int ceiling(int[] arr,int target) {
		int start = 0;
		int end = arr.length - 1;
		
		while(start<=end) {
			int middle = start+(end-start)/2;
			if(target<arr[middle]) {
				end = middle-1;
			}else if(target>arr[middle]) {
				start = middle+1;
			}else {
				return middle;
			}
		}
		return start;
	}
}

OP:-
The ceiling of the array is in index : 5


//Floor of a given number, using BS
//Floor of a number is basically greatest element of the array smaller than or equal to target number.
	
/*
 * Assume a sorted array
 * 
 * arr = [2,3,4,5,9,14,16];
 * target = 14;
 * 
 * steps to find floor of a number is:-
 * same as above(ceiling of number), but return end instead of -1, if target not found.  
 * 
 * when condition is VIOLATED, start(s)=end(e)+1; where, s>e;
*/

(EG):- to find the floor of a number in array, using BS. 

sol] 
package javatpoint;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;


public class Student{
	public static void main(String[] args) {
	
	//find the ceiling of a number using BS
	//Floor of a number is basically greatest element of the array smaller than or equal to target number.
	int[] arr= {2,3,5,9,14,16,18}; //sorted array
	int target = 15;
	int ans = ceiling(arr,target);
	System.out.println("The floor of the array is in index: "+ans);
	}
	
	static int ceiling(int[] arr,int target) {
		
		//what if target number is greatest than the largest number in array
		if(target>arr[arr.length-1]) {
			return -1;
		}
		
		int start = 0;
		int end = arr.length - 1;
		
		while(start<=end) {
			int middle = start+(end-start)/2;
			if(target<arr[middle]) {
				end = middle-1;
			}else if(target>arr[middle]) {
				start = middle+1;
			}else {
				return middle;
			}
		}
		return end;
	}
}

OP:-

The floor of the array is in index: 4
		
/*
 *  So basically this concludes to 2 results:-
 *  1] If you want to find the end You return floor.
 *  2] If you want to find the start You return ceiling.
 *  AND
 *  The time complexity is same as BS which is, O(log N)
*/

###################################################################################################################

LEET CODE PROBLEMS:-
------------------

1]  Find Smallest Letter Greater Than Target
    Link: https://leetcode.com/problems/find-smallest-letter-greater-than-target/

sol] 

package javatpoint;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;


public class Student{
	public static void main(String[] args) {
	
	//744. Find Smallest Letter Greater Than Target
	//Link: https://leetcode.com/problems/find-smallest-letter-greater-than-target/
	char[] letters = {'c','f','j'};
	char target = 'a';
	char result = nextGreatestLetter(letters,target);
	System.out.println(result);	
	}
	
	static char nextGreatestLetter(char[] letters,char target) {
		int start = 0;
		int end = letters.length-1;
		
		while(start<=end) {
			int middle = start + (end-start)/2;
			if(target<letters[middle]) {
				end=middle - 1;
			}else {
				start = middle + 1;
			}
		}
		
		return letters[start%letters.length];
	}
}

op:-

c

2] Find First and Last Position of Element in Sorted Array


sol]
package javatpoint;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;


public class Student{
	public static void main(String[] args) {
	
	// 34. Find First and Last Position of Element in Sorted Array

		
	int[] nums = {1,2,7,7,7,7,8,9};
	int target = 7;
	int[] result = searchRange(nums, target);
	System.out.println(Arrays.toString(result));	
	}
	
	public static int[] searchRange(int[] nums, int target) {
       
		int[] ans = {-1, -1}; //default ans for quest
		
		//check for first occurrence if target first
		int start = search(nums,target,true); //findStartIndex == true
		int end = search(nums,target,false); //findStartIndex == false
		
		//updates the value if new element exist
		ans[0] = start;
		ans[1] = end;
	    
		return ans;
	}
	
	static int search(int[] nums,int target, boolean findStartIndex) {
		
		int ans = -1; //default ans value is -1.
		
		//regular bs code until else.
		int start = 0;
		int end = nums.length-1;
		
		while(start<=end) {
			int middle = start + (end - start)/2;
			if(target < nums[middle]) {
				end = middle - 1;
			}else if(target > nums[middle]) {
				start = middle + 1;
			}else { //the change for this question
				ans = middle; //the ans
				if(findStartIndex == true) { //if more elements of the same target lies ahead we use this condition to get value.
					end = middle - 1;
				}else {//if more elements lie ahead of middle element we use this.
					start = middle + 1;
				}
			}	
		}
		return ans;
	}
	
}

op:-
nums =
[5,7,7,8,8,10]
target =
6
Output
[-1,-1]


3] To find Position of an element in infinite sorted array

sol]
package javatpoint;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;


public class Student{
	public static void main(String[] args) {
	
	// Position of an element in infinite sorted array
	// Amazon question
	
	// The approach is to reverse binary search and then actual binary search
	// This approach thus gives "log N + log N = 2log N == log N" - because constants are ignored in time complexity
	
		
	int[] nums = {3,5,7,9,10,90,100,130,140,160,170}; // assume it is infite sorted array(has no start or end)
	int target = 10; // if we set the target as 160, it shows error because we did not give an infinite array, but it works on infinite array as we double after every chunk in 2^n. eg:- 2^0, 2^1,2^2,2^3...,2^n
	int result = findRange(nums, target);
	System.out.println(result);	
	
	}
	
	static int findRange(int[] nums, int target) {
		
		//first find range of the array
		//first start with box of size 2
		int start = 0;
		int end = 1; //initial start and end values for a infinite array
		
		//condition for target to lie in the range
		while(target>nums[end]) {
			//new start
			int newStart = end+1;
			//double the box/chunk value to check for target
			//end = previousEnd + sizeOfBox * 2
			end = end + (end - start + 1) * 2;
			start = newStart;
		}
		
		return binarySearch(nums, target, start, end);
	}
	
	static int binarySearch(int[] nums, int target,int start,int end) {
		
		//As per the question, we can't determine start and end in an infinite array
		//We can't use "arr.length", since it is an infinite array
		
		//other than those 2 conditions, the rest is same as BS
		
		while(start<=end) {
			int middle = start + (end-start)/2;
			if(target<nums[middle]) {
				end = middle - 1;
			}else if(target>nums[middle]) {
				start = middle + 1;
			}else {
				return middle;
			}
		}
		return -1;
	}
	
	
}
op:-

4

4]

